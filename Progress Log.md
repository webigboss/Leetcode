# Progress Log

#|Title|Difficulty|Solved Date|Resolved Independently?|Original Solution|Other Solution Accepted|Revisite Date|Complexity Analysis and Notes|Solution summary
---|---|---|---|---|---|---|---|---|---
102|Binary Tree Level Order Traversal|Medium|3/23/2019|No|Level Order traversal (Recursion) O(n^2)||4/5/2019|Level Order Traversal by Queue, Time complexity is O(n)
107|Binary Tree Level Order Traversal II|Medium|3/23/2019|No|Level Order traversal (Recursion) O(n^2)|||
||||||||
110|Balanced Binary Tree|Easy|3/25/2019|Yes|Recursion+Binary Search|||
111|Minimum Depth of Binary Tree|Easy|3/26/2019|Yes|Recursion|||
112|Path Sum|Easy|3/27/2019|Yes|Recursion|||
94|Binary Tree Inorder Traversal|Medium|3/27/2019|Yes|Recursion|Interation||Morris Traversal
96|Unique Binary Search Trees|Medium|3/28/2019|No||||
95|Unique Binary Search Trees II|Medium|3/28/2019|No||||
98|Validate Binary Search Tree|Easy|3/29/2019|Yes|Inorder traversal|||
113|Path Sum II|Medium|3/30/2019|Yes|Recursion(using List store data)|||Recursion(using linked list)
99|Recover Binary Search Tree|Hard|3/30/2019|Yes|Recursion(twice)|||"1.Can it be solved with one recursive call?2.Morris Traversal"
103|Binary Tree Zigzag Level Order Traversal|Medium|3/31/2019|Yes|Recursion|||
105|Construct Binary Tree from Preorder and Inorder Traversal|Medium|3/31/2019|Inspired only by idea(developed code independently)|Recursion|||need to improve time, now only 14% faster than other; check 106, use Hashtable and indexes instead of Array.IndexOf() and Array.Copy
106|Construct Binary Tree from Inorder and Postorder Traversal|Medium|3/31/2019|Inspired only by idea(developed code independently)|Recursion|||
114|Flatten Binary Tree to Linked List|Medium|4/1/2019|Yes|Preorder traversal (Recursion)|||
129|Sum Root to Leaf Numbers|Medium|4/1/2019|Yes|Preorder traversal (Recursion)|||
144|Binary Tree Postorder Traversal|Medium|4/2/2019|Yes|Recursion / Iteration|||
145|Binary Tree Postorder Traversal|Hard|4/2/2019|No|Recursion / Iteration|||
226|Invert Binary Tree|Easy|4/3/2019|Yes|Recursion|||
116|Populating Next Right Pointers in Each Node|Medium|4/3/2019|Yes|Level Order Traversal + Recursion|||O(n^2), need to see if it's doable at O(n)
117|Populating Next Right Pointers in Each Node II|Medium|4/3/2019|Yes|Level Order Traversal + Recursion|||exact same solution as 116, need to find alternative solutions
173|Binary Search Tree Iterator|Medium|4/4/2019|Yes|Inorder traversal (Interative)|||
199|Binary Tree Right Side View|Medium|4/4/2019|Yes|Level Order traversal (Recursion)|||not too fast, need to explore other solutions
222|Count Complete Tree Nodes|Medium|4/5/2019|Yes|Recursion O(n) / Binary Search O(log(n)^2)|||need to check  the iterative binary search
11|Container With Most Water|Medium|4/6/2019|No|Two Pointers alike (not based on sorting array actually, just have two pointers)|||
12|Integer to Roman|Medium|4/6/2019|Yes|Specific to problem|||
17|Letter Combinations of a Phone Number|Medium|2019/4/7|No|DFS(BackTracking) / BFS||2019/6/3|revisited with BFS solution, and then optimized Hashtable by string array
18|4Sum|Medium|4/7/2019|No|2sum and 3sum |||
39|Combination Sum|Medium|4/8/2019|No|Backtracking|||
31|Next Permutation|Medium|4/8/2019|Inspired only by idea(developed code independently)|Specific to problem|||No need to use Array.Sort, because it is really a reverse of all the elements is needed. Explore backtracking solution at [here](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))
46|Permutations|Medium|4/9/2019|Yes|Backtracking|||
47|Permutations II|Medium|4/9/2019|Yes|Backtracking||4/11/2019|only faster than 20%, need to think of a way to get rid of usedIndexes, refer to other's solution could use a bool array. 4/11/2019: rewrite the solution with bool[] to mark the used element
40|Combination Sum II|Medium|4/10/2019|Yes|Backtracking|||
22|Generate Parentheses|Medium|4/10/2019|Yes|Backtracking|||this problem is leveled my understanding of backtracking
60|Permutation Sequence|Medium|4/11/2019|Yes|Backtracking/Specific calculation|||backtracking is not suitable for this problem in terms of time
77|Combinations|Medium|4/12/2019|Yes|Backtracking|||
78|Subsets|Medium|4/12/2019|Yes|Backtracking|||
89|Gray Code|Medium|4/12/2019|yes|Backtracking/Specific calculation|||follow up with other speficic calculate at [here](https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81)
79|Word Search|Medium|4/13/2019|Yes|Backtracking|||time and space is horrible, need to improve
90|Subsets II|Medium|4/13/2019|Yes|Backtracking|||
93|Restore IP Addresses|Medium|4/15/2019|Yes|Backtracking|||
131|Palindrome Partitioning|Medium|4/15/2019|Inspired only by idea(developed code independently)|Backtracking|||I think my solution is shorter than the answer with highest votes
33|Search in Rotated Sorted Array|Medium|4/17/2019|Inspired only by idea(developed code independently)|Binary Search|||time complexity O(log(n))
81|Search in Rotated Sorted Array II|Medium|4/17/2019|Inspired only by idea(developed code independently)|Binary Search|||time complexity O(log(n)), worst case O(n)
34|Find First and Last Position of Element in Sorted Array|Medium|4/17/2019|Yes|Binary Search|||
50|Pow(x, n)|Medium|4/17/2019|Yes|Binary Search|||
153|Find Minimum in Rotated Sorted Array|Medium|4/18/2019|Yes|Binary Search|||
162|Find Peak Element|Medium|4/18/2019|Yes|Binary Search|||
74|Search a 2D Matrix|Medium|4/19/2019|Yes|Binary Search|||time complexity is O(log(n)+log(m)), better than conceptually map the matrix to a 1 dimension array and do the binary search has time complexity O(log(n*m))
240|Search a 2D Matrix II|Medium|4/19/2019|No|Liner checking|||time complexity is O(n+m), not the optimal solution, check cracking the code interview 6th version chapter 10.9 for the binary search solution to archive logarithm time complexity
167|Two Sum II - Input array is sorted|Medium|4/20/2019|Inspired only by idea(developed code independently)|Two Pointers|||time complexity O(n), space complexity O(1), vs hashtable solution time complexity O(n), space complexity O(n), no better binary search solution found.
209|Minimum Size Subarray Sum|Medium|4/20/2019|No|Two Pointers alike (not based on sorting array actually, just have two pointers)|||Time complexity O(n), space complexity O(1). Worth of doing the O(nlog(n)) binary search solution to understand the idea of it
19|Remove Nth Node From End of List|Medium|4/21/2019|Yes|Specific to problem / Two Pointers alike|||one pass algorithm, Time complexity O(n), space complexity O(n), need to familiarize and finish the solution in solution section, they both have contant O(1) space complexity. Especially the one pass solution is brilliant.
61|Rotate List|Medium|4/21/2019|Yes|Two Pointers alike (not based on sorting array actually, just have two pointers)|||two pass algorithm, time complexity O(n), space complexity is constant O(1). Is there a one pass algorithm?
24|Swap Nodes in Pairs|Medium|4/22/2019|Yes|Two Pointers alike (not based on sorting array actually, just have two pointers)|||one pass algorithm, Time complexity O(n), space complexity O(1)
75|Sort Colors|Medium|4/22/2019|No|Counting Sort|||two pass algorithm, time complexity O(n), space complexity is constant O(1). There is a QuickSort solution which is O(nlog(n)) but is one pass: [here](https://leetcode.com/problems/sort-colors/discuss/26549/Java-solution-both-2-pass-and-1-pass)
80|Remove Duplicates from Sorted Array II|Medium|4/23/2019|Yes|Two Pointers alike (not based on sorting array actually, just have two pointers)|||
86|Partition List|Medium|4/24/2019|No|Two Pointers alike (not based on sorting array actually, just have two pointers)|||TC: O(n), SC: O(1)
48|Rotate Image|Medium|4/25/2019|No|Specific to problem|||
49|Group Anagrams|Medium|4/26/2019|No|Specific to problem|||
32|Longest Valid Parentheses|Hard|4/27/2019|No|Stack & DP|||TC: O(n), SC: O(n) for both Stack and DP solution
142|Linked List Cycle II|Medium|4/27/2019|Yes for HT, No for TP|Hashtable & Two Pointer|||Hashtable: TC: O(n), SC: O(n); Two Ponters: TC: O(n)?, SC: O(1)
23|Merge k Sorted Lists|Hard|4/28/2019|Inspired only by idea(developed code independently)|Specific to problem|||TC: O(nk), SC: O(1), k is the count of list array. My solution seems to be better than official solution 2. because save min value in a list so I can make sure one iterration will get all the nodes with min val, instead of interating min vals multiple times. Follow-up: check solution 3, under stand priority queue (heap)
55|Jump Game|Medium|4/28/2019|No|Backtracking & DP Top down & DP Buttom up & Greedy|||the solution article is brilliant
54|Spiral Matrix|Medium|4/29/2019|Yes|Specific to problem|||TC: O(n), SC: O(n)
56|Merge Intervals|Medium|4/29/2019|Yes|Bubble Sort|||TC: O(n^2), SC: O(1). Try other more efficient sorting algorithm. Like heapsort, quicksort, mergesort, etc.
59|Spiral Matrix II|Medium|4/30/2019|Yes|Specific to problem|||TC: O(n), SC: O(n)
62|Unique Paths|Medium|4/30/2019|No|Math & DP|||Math: O(n), SC O(1), DP: O(n^2), SC: O(n^2), DP solution can optimize the space complexity.
36|Valid Sudoku|Medium|5/1/2019|Yes|Hashtable|||
82|Remove Duplicates from Sorted List II|Medium|5/1/2019|Yes|3 Pointers|||TC: O(n), SC: O(1), one pass algorithm
206|Reverse Linked List|Easy|2019/5/2|Yes|Iteration & Recursion||2019/8/6|Iteration: TC: O(n), SC: O(1); Recursion: TC: O(n), SC: O(n)|Iterative: define a prev node, a temp node, iterate thorugh the linkedlist, on each iteration 1. save cur.next to temp, 2. change cur.next to prev node, 3. set prev = cur, 4. set cur = temp, 5, return pre when iteration is done; Recursive: 1. return the tail as the new head all the way up; 2. key operation is cur.next.next = cur, cur.next is the next node before reverse, assign its next to cur will reverse the direction; 3. set cur.next = null to avoid cycle in the list; 
92|Reverse Linked List II|Medium|5/2/2019|Yes|Iteration|||Iteration: TC: O(n), SC: O(1)
109|Convert Sorted List to Binary Search Tree|Medium|5/3/2019|Yes|Recursion|||TC: O(n), SC: O(n), same as official solution 2
138|Copy List with Random Pointer|Medium|5/3/2019|Yes|Hashtable|||TC: O(n), SC  O(n). There is a optimized solution which will archive SC O(1)
143|Reorder List|Medium|5/4/2019|Yes|covert to list|||TC: O(n), SC  O(n). There is a optimized solution which find the mid of the linkedlist first, reverse the sencond part and finally reorder the linked list. Without using list make its SC constant O(1)
147|Insertion Sort List|Medium|5/4/2019|Yes|Specific to problem|||TC: O(n), SC  O(1)
148|Sort List|Medium|5/5/2019|No|Merge Sort|||TC: O(nlog(n)), SC: O(log(n)), this problem asks for constant space complexiy, so optimal solution seems to be a bottom-up merge sort. Worth checking this [one](https://leetcode.com/problems/sort-list/discuss/239384/Java-Real-O(1)-space-No-recursion-only-iterative-merge-sort-with-full-comments)
160|Intersection of Two Linked Lists|Easy|5/6/2019|Yes for HT, No for TP|Hashtable & Two Pointer|||Hashtable: TC: O(m+n), SC: O(m) or O(n); Two Pointers: TC O(n+m), SC: O(1)
234|Palindrome Linked List|Easy|5/6/2019|Inspired only by idea(developed code independently)|Two Pointers|||TC: O(n); SC O(1)
237|Delete Node in a Linked List|Easy|2019/5/7|Yes|Specific to problem|||TC: O(n); SC: O(1), official solution is optimal that archives TC O(1)
63|Unique Paths II|Medium|2019/5/7|Yes|DP|||TC: O(m*n), SC: O(m*n), official solution doesn’t create a dp array but use the modify the obstacalGrid in place so it can archive SC O(1)
43|Multiply Strings|Medium|2019/5/8|No|Specific to problem, Math|||TC: O(m*n), SC: O(m+n)
64|Minimum Path Sum|Medium|2019/5/9|Yes|DP|||TC: O(m*n), SC: O(m*n), the dp 2D array could be ingored to use jagged array grid, to archive SC O(1)
71|Simplify Path|Medium|2019/5/9|Yes|Stack|||TC: O(n), SC: O(n)
73|Set Matrix Zeroes|Medium|2019/5/9|inspired only by idea(developed code independently)|In Place Algorithm|||TC: O(m*n), SC: O(1)
120|Triangle|Medium|5/10/2019|Yes|DP|||
123|Best Time to Buy and Sell Stock III|Hard|5/11/2019|No|DP & One Pass|||DP: O(k*n), SC: O(k*n); OnePass: TC: O(n), SC: O(1). The DP solution can be further optimized to SC: O(k)
152|Maximum Product Subarray|Medium|5/11/2019|No|DP|||TC: O(n), SC:O(1). Solution explaination [here](https://leetcode.com/problems/maximum-product-subarray/discuss/48230/Possibly-simplest-solution-with-O(n)-time-complexity/181239)
51|N-Queens|Hard|5/11/2019|Yes|Backtracking|||
52|N-Queens II|Hard|5/11/2019|Yes|Backtracking|||
169|Majority Element|Easy|2019-05-12|Yes|Sorting / Hashtable / Divide & Conquer|||Sorting: TC: O(nlogn), SC: O(1); Hashtable: TC: O(n), SC: O(n); Divide & Conquer: TC: O(nlogn), SC: O(logn)
189|Rotate Array|Easy|2019-05-12|Yes|Queue / Array / Reverse|||Queue & Array TC: O(n), SC: O(n); Reverse: TC: O(n), SC: O(1)
216|Combination Sum III|Medium|2019/5/13|Yes|Backtracking|||
8|String to Integer (atoi)|Medium|2019/5/13|Yes|Specific to problem|||
165|Compare Version Numbers|Medium|5/14/2019|Yes|Spefific to problem|||
168|Excel Sheet Column Title|Easy|5/14/2019|Yes|Math|||TC: O(k) k = n/26; SC: O(k)
171|Excel Sheet Column Number|Easy|5/14/2019|Yes|Math|||TC: O(n) n=s.Length; SC: O(1)
128|Longest Consecutive Sequence|Hard|5/15/2019|Yes for Sorting, Inspired for HT|HashTable / Sorting|||Sorting: TC: O(nlogn), SC: O(1); Hashtable: TC: O(n), SC: O(n)
155|Min Stack|Easy|5/15/2019|Yes for List|List / One Stack|||
154|Find Minimum in Rotated Sorted Array II|Hard|5/16/2019|Yes|Binary Search|||TC: O(log(n)) (average), O(n) (worst); SC: O(1)
217|Contains Duplicate|Easy|5/16/2019|Yes|Hashtable|||TC: O(n), SC: O(n); it can be solved by sorting too
219|Contains Duplicate II|Easy|5/16/2019|Yes|Hashtable|||TC: O(n), SC: O(n)
228|Summary Ranges|Medium|2019/5/17|Yes|One Pass|||TC: O(n), SC: O(n)
76|Minimum Window Substring|Hard|2019/5/18|Yes|Hashtable|||TC: O(n), SC: O(n); Bravo! Check this post for template summarization of the substring problem. [here](https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-'substring'-problems)
139|Word Break|Medium|2019/5/18|No|DP||2020-02-21|TC: O(n^3), SC: O(n); Revisit2020-02-20 DP: TC: O(n^2), SC: O(n)|2020-02-20: optimized DP in the revisit solution, basically changed iteration direction of the sub interation, so as to reduce repetitive checking, also use stringbuilder to get the substring instead of use substring(), reduced the time complexity from O(n^3) to O(n^2)
134|Gas Station|Medium|2019/5/19|Yes for the one with O(n^2)|One Pass|||Brutal: TC: O(n^2), SC: O(1); OnePass: TC: O(n), SC: O(1)|
150|Evaluate Reverse Polish Notation|Medium|2019/5/19|Inspired only by idea(developed code independently)|Stack|||Left to Right: TC: O(n), SC: O(n). There is another Right to left solution which is less straight-forward. It failed at a test case which I didn't figure out the reason why. I added the code for it anyway
115|Distinct Subsequences|Hard|2019/5/20|Inspired only by idea(developed code independently)|DP|||TC: O(n*m), SC: O(n*m). Bravo! Think of the parrtern independently!
178|Rank Scores|Medium|2019/5/20|Yes|SQL|||
191|Number of 1 Bits|Easy|2019/5/21|Yes|Bit Manipulation|||
190|Reverse Bits|Easy|2019/5/21|Yes|Bit Manipulation|||there is a optimal solution that uses bitwise operation at [here](https://leetcode.com/problems/reverse-bits/discuss/54746/Java-Solution-and-Optimization)
133|Clone Graph|Medium|2019/5/22|Yes|Recursion & Hashtable|||TC: O(n), SC: O(n); this is essentially the Depth first search for graph theory, the recursion is equivalent of a stack structure, however to archive deep copy, stack data structure seems to be less straight-forward than implementing by recusion
151|Reverse Words in a String|Medium|2019/5/22|Yes|Stack|||TC: O(n), SC: O(n)
127|Word Ladder|Medium|2019/5/22|Inspired only by idea(developed code independently)|Breadth First Search(Graph)|||TC: O(n * m * n) or O(n * m) n: number of word, m: length of each word; SC: O(n * m)
130|Surrounded Regions|Medium|2019/5/23|Inspired only by idea(developed code independently)|BFS(Queue) & DFS(Recursion)|||TC: O(n * m); SC: O(n * m)
202|Happy Number|Easy|2019/5/23|Yes|Hashtable|||TC: O(n), SC: O(n)
198|House Robber|Easy|2019/5/23|Yes|DP|||TC: O(n), SC: O(n)
200|Number of Islands|Medium|2019/5/24|Yes|BFS(Queue) & DFS(Recursion)|||TC: O(n * m); SC: O(n * m)
257|Binary Tree Paths|Easy|2019/5/24|Yes|DFS(Binary Tree)|||TC: O(n), SC: O(n)
207|Course Schedule|Medium|2019/5/25|Inspired only by idea(developed code independently)|Topological Sort: DFS(Recursion+Stack); Kahn's algorithm|||DFS: TC: O(n+m), SC: O(n+m); Kahn: TC: O(n+m), SC: O(max(n, m)). n: length of numCourse, m: length of prerequisites
181|Employees Earning More Than Their Managers|Easy|2019/5/25|Yes|SQL|||
210|Course Schedule II|Medium|2019/5/26|Yes|Topological Sort: DFS(Recursion+Stack); Kahn's algorithm|||DFS: TC: O(n+m), SC: O(n+m); Kahn: TC: O(n+m), SC: O(max(n, m)). n: length of numCourse, m: length of prerequisites
176|Second Highest Salary|Easy|2019/5/26|Yes|SQL|||
175|Combine Two Tables|Easy|2019/5/26|Yes|SQL|||
177|Nth Highest Salary|Medium|2019/5/26|Yes|SQL|||
196|Delete Duplicate Emails|Easy|2019/5/27|Yes|SQL|||
126|Word Ladder II|Hard|2019/5/27|Yes|BFS+DFS(Backtracking)|||TC: O(n*m*n) or O(n*m)? n: number of word, m: length of each word; SC: O(n*m)
172|Factorial Trailing Zeroes|Easy|2019/5/28|No|Math|||TC: O(log5(n)), SC:O(log5(n))
279|Perfect Squares|Medium|2019/5/28|Yes|BFS|||TC: O(sqrt(n)), SC: O(sqrt(n)); there is also DP solutions
187|Repeated DNA Sequences|Medium|2019/5/28|Yes|Hashtable|||TC: O(n), SC: O(n); can optimize this solution by bit manipulation
204|Count Primes|Medium|2019/5/29|No|Specific to problem|||TC: O(nloglog n), SC: O(n) https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#cite_note-intro-8
231|Power of Two|Easy|2019/5/29|Yes|Math|||TC: O(logn)?, SC: O(1). There are 4 different ways to solve Iterative&Recursive&Bit operation&Math 
201|Bitwise AND of Numbers Range|Medium|2019/5/31|Yes|Bit Manipulation|||TC: O(Min(n.length, m.length)); SC: O(1)
213|House Robber II|Medium|2019/5/31|Yes|DP|||TC: O(n), SC: O(n)
205|Isomorphic Strings|Easy|2019/6/1|Yes|Hashtable|||TC: O(n), SC: O(1); Although we do use extra space, the space complexity is O(1)O(1) because the table's size stays constant no matter how large n is.
215|Kth Largest Element in an Array|Medium|2019/6/1|Yes|Heapsort / Quickselect(20190630)||2019/6/30: quickselect recursion; 2019/07/03: quickselect interation in place|Heapsort: TC: O(nlogn), SC: O(1); Quickselect recursion: TC: O(n), SC: O(log(n))?; Quickselect in place: TC:O(n), SC:O(1). for quickselect approach, the partition scheme I used is Lomuto, there is another Hoare partition scheme which has improved worse case, but I also introduced a way to ramdomize the pivot, this will also improve the worse case of Lomuto partition.
242|Valid Anagram|Easy|2019/6/1|Yes|Hashtable|||TC: O(n), SC: O(1); Although we do use extra space, the space complexity is O(1)O(1) because the table's size stays constant no matter how large n is.
184|Department Highest Salary|Medium|2019/6/2|Yes|SQL|||
183|Customers Who Never Order|Easy|2019/6/2|Yes|SQL|||
179|Largest Number|Medium|2019/6/2|Yes|Heap Sort|||TC: O(nlogn), SC: O(1);
164|Maximum Gap|Hard|2019/6/3|Yes|Radix Sort|||TC: O(d(n+k)) = O(n); SC: O(n+k) = O(n)
180|Consecutive Numbers|Medium|2019/6/4|No|SQL|||
221|Maximal Square|Medium|2019/6/4|No|DP|||TC: O(n*m), SC: O(n*m), there is a optimal solution to reduce SC to O(n)
836|Rectangle Overlap|Easy|2019/6/4|Yes|Math|||TC: O(1), SC: O(1);
185|Department Top Three Salaries|Hard|2019/6/5|Yes|SQL|||
230|Kth Smallest Element in a BST|Medium|2019/6/5|Yes|Recursion / Iteration|||Recursion: TC: O(n), SC: O(n); Iteration: TC: O(H+k), SC: O(H+k). H: tree's height, k: for the kth element
229|Majority Element II|Medium|2019/6/6|Yes (Hashtable)|Hashtable / Boyer-Moore Majority vote|||Hashtable: TC:O(n), SC: O(n), Boyer-Moore Majority Vode: TC: O(n), SC: O(1)
235|Lowest Common Ancestor of a Binary Search Tree|Easy|2019/6/6|Yes|Iteration|||TC: O(n) (worst case, when BST is skewer, if the tree is balanced, then will be O(logn), SC: O(1); 
220|Contains Duplicate III|Medium|2019/6/8|No|SortedSet / Bucket Dict|||SortedList: TC: O(nlogk), SC: O(k); Bucket dict:TC: O(n), SC: O(k)
223|Rectangle Area|Medium|2019/6/8|No|Math|||TC: O(1), SC: O(1);
232|Implement Queue using Stacks|Easy|2019/6/8|Yes|Design|||TC: O(n)(Push), O(1)(Pop), SC: O(n); the alternative implementation for Pop by Amotrized is brilliant
241|Different Ways to Add Parentheses|Medium|2019/6/8|inspired only by idea(developed code independently)|Recursion (DFS alike)|||I tried to solve it by BFS but it doesn't quite fit for this problem because it will generate duplicates, but the code is still worth revisiting
225|Implement Stack using Queues|Easy|2019/6/9|Yes|Specific to problem|||Two Queue: TC: O(n)(Push), O(1)(Pop); One Queue: TC: O(n)(Push), O(1)(Pop)
238|Product of Array Except Self|Medium|2019/6/9|Inspired only by idea(developed code independently)|Specific to problem|||TC:O(n), SC: O(n); There is an optimal solution that with SC: O(1)
239|Sliding Window Maximum|Hard|2019/6/9|No|Deque|||TC:O(n^2), SC: O(n); the two pass linear solution is also worth checking: [here](https://leetcode.com/problems/sliding-window-maximum/discuss/65881/O(n)-solution-in-Java-with-two-simple-pass-in-the-array)
236|Lowest Common Ancestor of a Binary Tree|Medium|2019/6/10|Yes|DFS(Recursion)|||TC: O(n), SC: O(n); first time come up with a recursion with a return type, code is nice and tidy, bravo! there is iterative solution
258|Add Digits|Easy|2019/6/10|Yes|Math|||TC: linear O(k), SC: O(1); there is a O(1) solution 
263|Ugly Number|Easy|2019/6/11|Yes|Math|||
264|Ugly Number II|Medium|2019/6/11|No|DP|||TC: O(n), SC: O(n)
268|Missing Number|Easy|2019/6/12|Yes|Math|||TC: O(n), SC: O(1)
91|Decode Ways|Medium|2019/6/12|Yes|DP|||TC: O(n), SC: O(n)
41|First Missing Positive|Hard|2019/6/12|Yes for (SC: O(n))|Specific to problem|||Hashtable: TC: O(n), SC: O(n); Swap Numbers: TC:O(n), SC: O(1)
278|First Bad Version|Easy|2019/6/14|Yes|Binary Search|||TC: O(logn), SC: O(1)
227|Basic Calculator II|Medium|2019/6/14|No|Stack|||TC: O(n), SC: O(1)
283|Move Zeroes|Easy|2019/6/15|Yes|Specific to problem|||TC: O(n), SC: O(1)
290|Word Pattern|Easy|2019/6/15|Yes|HashTable|||TC: O(n), SC: O(n)
292|Nim Game|Easy|2019/6/16|Yes|Specific to problem|||TC: O(1), SC: O(1)
224|Basic Calculator|Hard|2019/6/17|No|Stack|||TC: O(n), SC: O(n)
326|Power of Three|Easy|2019/6/17|Yes|Math|||TC: O(log(sqrt(n)))?, SC: O(1)
146|LRU Cache|Medium|2019/6/18|Yes|Hashtable|||TC: Get: O(1), Put: O(n), SC: O(n); there is an solution use doubly linked list to archive O(1) for both get and put 
274|H-Index|Medium|2019/6/18|Yes|Sorting / Counting Sort|||Sorting: TC: O(nlogn), SC: O(1); Counting Sort: TC: O(n), SC: O(n)
275|H-Index II|Medium|2019/6/18|Yes|Logrithm pass|||TC: O(logn), SC: O(1)
287|Find the Duplicate Number|Medium|2019/6/19|No|Cycle detection/Sorting/Hashtable|||Cycle Detection: TC: O(n), SC: O(1);Sorting: TC: O(nlogn), SC: O(1); Hashtable: TC: O(n), SC: O(n) 
299|Bulls and Cows|Medium|2019/6/20|Yes|Specific to problem|||one pass or two pass: TC: O(n), SC: O(n)
289|Game of Life|Medium|2019/6/20|Yes|Specific to problem|||TC: O(n*m), SC: O(1)
300|Longest Increasing Subsequence|Medium|6/21/2019|No|Recursion with memorization / DP|||Recursion with memo: TC: O(n^2), SC: O(n^2)
303|Range Sum Query - Immutable|Easy|6/21/2019|No for DP|DP|||TC: O(n), SC: O(n)
304|Range Sum Query 2D - Immutable|Medium|6/22/2019|Yes (caching by row)|DP(caching by row / caching by area|||caching by row: TC: Query:O(m), pre-computation: O(n*m), SC: O(n*m); caching by area: TC: Query: O(1), pre-computation: O(n*m), SC: O(n*m)
306|Additive Number|Medium|6/22/2019|Yes|Backtracking||| 
307|Range Sum Query - Mutable|Medium|6/23/2019|Yes|DP|||DP: TC: query: O(1), update: O(n), pre-computation: O(n); SC: O(n). There are segment tree apporach which have logarithmic (logn) query time complexity.
310|Minimum Height Trees|Medium|6/25/2019|No|Specific to problem|||TC: O(n), SC: O(n)
309|Best Time to Buy and Sell Stock with Cooldown|Medium|6/25/2019|No|DP|||TC: O(n), SC: O(n), there is another way to design DP approach with 3 DP arrays, check [here](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking))
313|Super Ugly Number|Medium|6/26/2019|Yes|DP|||TC:O(n*m), SC: O(n+m); n: nth ugly number, m: number of primes
319|Bulb Switcher|Medium|6/26/2019|No|Math|||TC: O(1), SC: O(1)
318|Maximum Product of Word Lengths|Medium|6/26/2019|No|Bit Manipulation|||TC: O(n*m), SC: O(n)
322|Coin Change|Medium|6/27/2019|Yes|DP (bottom up)||6/29/2019: improved the code by removed some unneccessary logic; implemented DP top down with memoization.|TC: O(n*m), SC: O(m); n: number of coins, m: amount. Bravo for figuring out DP deduce.
342|Power of Four|Easy|6/27/2019|Inspired only by idea(developed code independently)|Base Conversion|||Base Conversion: TC: O(log4(n)), SC: O(1);
328|Odd Even Linked List|Medium|6/27/2019|Yes|Specific to problem|||TC: O(n), SC: O(1)
344|Reverse String|Easy|6/28/2019|Yes|Specific to problem|||TC: O(n), SC: O(1)
312|Burst Balloons|Hard|6/28/2019|No|Divide and Conquer with Memo|||DC with memo: TC: O(n^2), SC: O(n^2)
345|Reverse Vowels of a String|Easy|6/28/2019|Yes|Two Pointers|||TC: O(n), SC: O(n) (created a char array)
324|Wiggle Sort II|Medium|6/29/2019|No|Sort|||TC: O(n) (assume FindKthLargest is O(n)), SC: O(n).  There is a in place optimal solution
347|Top K Frequent Elements|Medium|6/30/2019||HashTable / Sort|||TC: O(nlog(n)), SC: O(n), there is not native PriorityQueue implementation in C#, so the solution only works for Java
349|Intersection of Two Arrays|Easy|7/1/2019|Yes|Hashtable|||TC: O(n+m); SC: O(n+m)
343|Integer Break|Medium|7/1/2019|No|DP / Math|||DP: O(n^2), SC: O(n); DP optimized by Math: TC: O(n), SC: O(n)
350|Intersection of Two Arrays II|Easy|2019/7/2|Yes|Hashtable|||TC: O(n+m); SC: O(n+m)
337|House Robber III|Medium|2019/7/2|Yes|Dfs + Memoizaiton|||TC: O(2n) = O(n)?; SC: ? For TC: think about every node will be only calculated twice, one robbing, one for skipping 
341|Flatten Nested List Iterator|Medium|2019/7/5|Yes|Stack|||TC: HasNext(): O(n), Next(): O(1), SC: O(n)
338|Counting Bits|Medium|2019/7/5|Yes|Bit Manipulation + DP|||TC:O(n), SC: O(n)
357|Count Numbers with Unique Digits|Medium|7/5/2019|Yes|Backtracking / DP|||Backtracking: exponential; DP: TC:O(n), SC: O(n);
367|Valid Perfect Square|Easy|7/5/2019|Yes|Binary Search|||TC: O(logn), SC: O(1)
37|Sudoku Solver|Hard|7/6/2019|Yes|Backtracking|||TC: exponential, SC: O(1) since sudoku is constant 9*9.
331|Verify Preorder Serialization of a Binary Tree|Medium|7/7/2019|Yes|Stack|||TC:O(n), SC: O(n)
334|Increasing Triplet Subsequence|Medium|7/7/2019|Yes|Two Pass|||TC:O(n), SC: O(1)
208|Implement Trie (Prefix Tree)|Medium|7/8/2019|Inspired only by idea(developed code independently)|Trie||2020-02-20|TC: Insert, search, startwith: O(n), SC: O(m); n: count of characters of current word, m: count of total characters in the tree
211|Add and Search Word - Data structure design|Medium|7/8/2019|Yes|Trie+Recursion/Trie+Iterative+BFS|||TC: Insert, O(n), search: O(m); SC: O(m); n: count of characters of current word, m: count of total characters in the tree
377|Combination Sum IV|Medium|7/9/2019|Inspired only by idea(developed code independently)|Recursion / DP|||Recursion: TC: exponential; SC: exponential; DP: TC: O(n*m); SC: O(n); n: target, m: length of nums;
365|Water and Jug Problem|Medium|7/9/2019|No|Math|||TC: O(n), SC: O(1)
371|Sum of Two Integers|Easy|2019/7/10|Yes|Bit Manipulation|||TC: O(1), SC: O(1)
383|Ransom Note|Easy|2019/7/10|Yes|Hashtable|||TC:O(n), SC: O(n)
25|Reverse Nodes in k-Group|Hard|2019/7/11|Yes|Inplace reverse LinkedList|||TC: O(n), SC: O(1)
332|Reconstruct Itinerary|Medium|07/12/2019|Yes|DFS(Recursion)|||TC: exponential, SC: O(n), in problem is essentially a directed graph with more than 1 verticies at same direction, PriorityQueue can sort and track remaining vertices in one short, however c# doesn't have it, so I used dictionary of sortedset to sort verices,  and dictinary of int to count remaining vertices while during the DFS. alternitavely I can use sortedList to archive the same as PriorityQueue but with worse time complexity.  
372|SuperPow|Medium|7/12/2019|No|Math+Recursion|||TC:O(n), SC: O(n); n: b's length
373|Find K Pairs with Smallest Sums|Medium|7/13/2019|No|PriorityQueue(Heap)|||TC: O(n^2), SC: O(n); n:nums2's length; sortedList by default doesn't allow duplicated key. need to know how to use Icomparer to define comparer that allow duplicate key
387|First Unique Character in a String|Easy|2019/7/14|Yes|Hashtable|||TC: O(n), SC: O(n)
368|Largest Divisible Subset|Medium|2019/7/15|No|DP|||TC: O(n^2), SC: O(n)
375|Guess Number Higher or Lower II|Medium|07/16/2019|No|DP(Top Down)/DP(Bottom Up)|||DP(TopDown): TC: O(n^2), SC: O(n^2); DP(Bottom up): TC: O(n^3)?, SC: O(n^2)
376|Wiggle Subsequence|Medium|07/17/2019|Yes|DP|||TC: O(n), SC: O(n); check the solution section, it has better DP thoughts and greedy solution
378|Kth Smallest Element in a Sorted Matrix|Medium|2019/7/17|Yes|PriorityQueue(Heap)|||TC: O(n^2), SC: O(n); used SortedList to implement PriorityQueue as C# doesn't have native prorityqueue class, native PQ will have TC: O(nlogn), SC: O(n)
389|Find the Difference|Easy|2019/7/18|Yes(hashtable)|Hashtable / Bit Manipulation|||Hashtable: TC: O(n), SC: O(n); BitManipulation: TC:O(n), SC: O(1)
390|Elimination Game|Medium|07/18/2019|No|Specific to Problem|||TC: O(n), SC: O(1)|1. have an int and keep updating it as the length of remaining numbers; 2. analysis case from left or from right, from left will always start from the first num, which will visit the first num, while from right, whether the left first num will be visited depends on odd/even of remaining element
380|Insert Delete GetRandom O(1)|Medium|07/19/2019|inspired only by idea(developed code independently)|Hashtable+ List Swap|||TC: O(1), SC: O(n)|1. using a list to calculcate the random fron Random(), but it’s length is determined by the dictionray, meaning any element exceeds the count of dict will not be considered as an element of this list, removing item by swaping item to list end;
374|Guess Number Higher or Lower|Easy|7/21/2019|Yes|Binary Search|||TC:O(logn), SC: O(1)|
382|Linked List Random Node|Medium|7/21/2019|Yes(hashtable)|Hashtable/Reservoir sampling|||Hashtable: TC: O(n), SC: O(n); Reservoir sampling: TC:O(n), SC:O(1)|
384|Shuffle an Array|Medium|7/21/2019|No|Fisher-Yates|||Shuffle:TC:O(n), SC:O(1)|
400|Nth Digit|Easy|7/22/2019|inspired only by idea(developed code independently)|Math|||TC: O(n), SC:O(1); n: length of number n|1.find the length of the number where the nth digit is from; 2.find the actual number where the nth digit is from; 3 .find the nth digit and return
30|Substring with Concatenation of All Words|Hard|7/23/2019|inspired only by idea(developed code independently)|Hashtable|||TC: O(n^2), SC: O(m), m: words.Length, n: s.Length|1. have 2 hashtable, one record expected, one record found, have a counter to count all words added to found hashtable, iterate through the string s and add to found hashtable if it exist in expected, but cannot be greater than the count in expected.
398|Random Pick Index|Medium|7/23/2019|Yes|Reservoir Sampling|||TC: O(n), SC: O(1), input num doesn't count as extra space|1. using reservoir sampling, as this problem indicates that to much extra space used is not allowed, so hashtable won’t work. 2. reservoir sampling generally means if we want to randomly select k from n element, we first select the first k element, and start from the k+1 element, it has the probability of k/k+1 to replace a random element in the selected k element. 3. this problem is a special case when k = 1;
57|Insert Interval|Hard|07/24/2019|Yes|Overlapping Checking|||TC: O(n), SC: O(n)|1. using the overlapping checking logic MaxLeft compare to MinRight, iterate intervals array, add intervals overlapped with newInterval into a list(overlappings), add the rest into another list; 2. record the starting index of the overlapping, or keeping adding this index of current interval[1] < newInterval[0]
394|Decode String|Medium|07/24/2019|Yes|Stack|||TC: O(n), SC: O(n)|1. stack is always the go-to data structure for these nested multi-level logical data; 2. watch for ] as signed to pop from stack, process and then push back to stack; 3. the k number could be more than 1 digit.
385|Mini Parser|Medium|07/25/2019|Yes|Stack|||TC: O(n), SC: O(n)|1. use stack as it fit for nesting logic; 2. this problem's hard to understand, basically NestingInteger can either be an int or a list, it cannot be both; 3. iterate through the string, create a new  list NestedInteger when meet a '['; 4. use stringbuilder to record number in the string, call Add when if ',' is met; 5 when ']' is met, pop current nestedInteger from stack and Call Add to add it to the previous one in the stack.
45|Jump Game II|Hard|07/26/2019|Yes|DP / Greedy|||DP: TC: O(n^2), SC: O(n); Greedy backward iteration: TC: O(n^2), SC(1); Greedy forward(Optimal): TC:O(n), SC: O(1)|1. DP: polynomial iteration, dp[i] = min{dp[j] + 1}, (0 =< j< i); 2.Greedy forward: starting with interating the first element's possible jumps, find the farthest index max{i+nums[i]}, when reach the end of range, set next end point to the farthestIndex and keep interating the array to it's end, counting the jump counts every time we reach the range end point;
44|Wildcard Matching|Hard|2019/7/26|No|Backtracking / Greedy|||Greedy: TC: O(n*m), SC: O(1), n:s.Length, m: p.Length|Greedy: 1. have 2 index pi, si, when p[pi] == s[si] or p[pi] == '?', advance both pi and si; 3. have a int var to save index of last *, and last index of s after matching, when p[pi]=='*', starting with make * match empty, so pi advance by 1 but lastAfterMatch remains at si; 4: if add another case for lastStar != -1, this case will be hit when wrong answer found, reset pi back to lastStar, pi still advance by 1, but si advance from lastAfterMatch by 1, since we know current lastAfterMatch led to a wrong answer.
297|Serialize and Deserialize Binary Tree|Hard|2019/7/27|Np|Preorder DFS(Iterative) / Preorder DFS(Recursive)|||TC: O(n), SC: O(n)|1.serialize: recursion is trivial, iterative is also trival but need add a little step to append 'x' after a null treenode is met; 2. deserialize: recursion: just use a queue  and follows the same preorder traversal recursive calling, the element will be dequeued the in the correct order; iterative: iterate through the splited data string, define a stack, a dummyroot, define a nextnode, a currrent node, follow the same way of iterative traversal, everytime cur is null, pop a node from the stack and set its right as cur, otherwist pop cur into the stack and set its left to cur;
399|Evaluate Division|Medium|2019/7/27|Yes|DFS (Recursive) |||TC: O(q(v+e)), SC: O(q+v+e)? q:queries.Length, v: vertices count, e:edges count|1. DFS recursion search, using backtracking. First create all dictionary of edges and value between then. And then create a dfs recursion method; then iterate through the queries; 2. please note we need to record visited vertices by hashset; 3. the corner case of vertices visit itself need to be considered and covered
395|Longest Substring with At Least K Repeating Characters|Medium|2019/7/28|inspired only by idea(developed code independently)|Recursion / Sliding window(two pointers)|||Recursion: TC: O(n^2) or O(n^3); SC: O(n^2)|Recursion: 1.continuesly find the count of char that are less than k and split the string into subs, and pass all subs to current method recursively; 2, if string length is less than k, return 0; if all chars count are greater or equals to k, then return length of string; otherwise just return the max result from recursion call; Sliding Window: Another sliding window question, the same as Leetcode 340, the template is quite symmetric. The time complexity is O(26N)
42|Trapping Rain Water|Hard|7/28/2019|inspired only by idea(developed code independently)|Brutal Force/ DP / Two Pointers (to be completed) / Stack (to be completed)|||BrutalForce: TC: O(n^2), SC: O(1); DP: TC: O(n), SC: O(n);|intuition is for each element in height, find left and right max value, and the min of the 2 minus height[i] will be the answer for i, the result is sum of all element; DP: have 2 arrays to save leftMax and rightMax, note that to get the rightMax, we need to iterate from right to left. vice versa;
84|Largest Rectangle in Histogram|Hard|2019/7/29|No|Stack|||Stack: TC: O(n), SC: O(n)|Stack: [leetcode](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/28900/O(n)-stack-based-JAVA-solution); [GeekForGeek](https://www.geeksforgeeks.org/largest-rectangle-under-histogram)
85|Maximal Rectangle|Hard|2019/7/30|Yes|Stack|||Stack: TC: O(n*m), SC: O(m), n: matrix.Length; m: matrix[0],Length|Stack: based on the stack solution for LC84, create an int array heights, interate through the matrix's and and update it's value, treat it like a histogram, if matrix[y][x] == '1', height[x] grow by 1, else if matrix[y][x] == '0' reset height[x] to 0; pass heights to the sub routine of finding the max rectangle in histogram.
401|Binary Watch|Easy|07/31/2019|No|Bit Manipulation / Backtracking (to be implemented)|||Bit Manipulation: TC: O(12*60*n), SC: O(1) |Bit Manipulation: implement bitCount to return number of all 1-bit.  iterate from hours 0-11, minutes 0-59, find all possible time if the bitCount matches num. 
135|Candy|Hard|07/31/2019|No|Greedy two arrays / Greedy one array (to be implemented) /Greedy one pass with constant space (to be implemented)|||Greedy two arrays: TC: O(n), SC: O(n)|two arrays: define 2 arrays left2Right and right2Left, have 2 passes from left to right and right to left to populate these 2 arrays, e.g. for left2Right, if(ratings[i] > ratings[i-1]), then left2Right[i] = left2Right[i-1]+1; else, left2Right[i]=1;  one array: same as two array for scanning from left to right, only difference is doing the right to left scan, update the same array if candies[i] > candies[i + 1], then candies[i] = max(candies[i], candies[i + 1] + 1)
386|Lexicographical Numbers|Medium|08/01/2019|inspired only by idea(developed code independently)|DFS(Recursion) / Iteration (to be implemented)|||DFS(Recursion): TC: O(n), SC: O(1)|DFS(Recursion): visualize the numbers in a tree, e.g. for 1, it's children will be 10-19; and for 11, its children will be 110-119;
352|Data Stream as Disjoint Intervals|Hard|08/02/2019|inspired only by idea(developed code independently)|SortedSet / Dynamically update on List (to be implemented)|||SortedSet: AddNum: O(logn), GetIntervals: O(n); List: AddNum: O(n), GetIntervals: O(n);|SortedSet: AddNum simply adding the number into sortedset, GetIntervals: iterate all the sortedSet, record startNum, when curNum = preNum + 1, continue; else insert to list [start, preNum], reset start to curNum; 
404|Sum of Left Leaves|Easy|8/3/2019|Yes|DFS(Iterative) / DFS (Recursive) (to be implemented)|||DFS(Iterative): TC: O(n), SC: O(n)|DFS(Iterative): same pattern with iterative pre/in order traversal. Before adding the left node to stack, check if this node doesn't have any child node. 
405|Convert a Number to HexadecimalConvert a Number to Hexadecimal|Easy|8/3/2019|No|Bitwise shift operation|||bitwise shift: TC: O(1), SC: O(1)|1. hexadecimal needs to be formed from usigned int; 2.use bitwise and '& 15' to get the right most 4 bit which represent a hex number; 3. define a char array to map the int to hex number char; 4. use bitwise right shift to shift 4 bit everytime until current num equals to 0;
316|Remove Duplicate Letters|Hard|8/5/2019|No|Stack|||Stack|Stack: the idea is if cur letter is lexicographical less than a previous letter, and this previous letter will apprear after cur letter, then it's safe to remove the previous letter from the answer. 1. define a stack, a bool array length = 26 to indicate if a letter is in the stack, define an int array length = 26 to record count of letter; 2. iterate through the string, if cur letter is less than the letter on the top of stack and top letter remainings in the letterCount array is greater than 0, then keep poping up the top letter, and update bool array of this letter to false; 3. if cur letter is greater or equal to top letter in the stack and it's not in the stack, push into the stack.
402|Remove K Digits|Medium|8/5/2019|Yes|Stack|||Stack: TC:O(n), SC:O(n)|Stack: 1. use a stack, iterate through the string, when cur number is less than top of the stack, keep popping top number until cur number is bigger or equals to top number, push cur number into the stack, k--, till k =0; 2. there are cases that after iteration the removed number is less than k, then we need to make sure only include num.Length - k in the answer; 3. also be mindful that leading zeros needs to be removed;
415|Add Strings|Easy|8/10/2019|Yes|Specific to problem|||TC:O(n), SC:O(1)|1. use string.PadLeft(length, char) to make to num the same length; 2. iterate from tail to head, declare a remainder and advance, apply operation directly to chars, e.g. sum = num1[i] - '0' + num2[i] - '0', remainder = sum % 10, advance = sum / 10; 3. if advande is not 0 after iteration, then add the prepend the advance to the head of the result before returning it.
1114|Print in Order|Easy|08/13/2019|No|Multi-Threading|||TC:O(1), SC:O(1)|use AutoResetEvent (or ManualResetEvent) from System.threading, define 2 of them as properties to guard 2nd and 3rd print method. nitialize them in the constructor with false parameter stands for they are locked. Call Set() to release the signal (unlock) respectivelly. the 2nd and 3rd should check whether current thread is blocked by calling WaitOne() before critical section (printing logic)
1144|Decrease Elements To Make Array Zigzag|Medium|08/16/2019|inspired only by idea(developed code independently)|Specific to problem|||TC: O(n), SC: O(1)|the optimal solution is either making sure all even indexed element is greater than odd indexed element, or all odd indexed element is greater than even indexed element, check the even indexed element and odd indexed element separately,  the minimal one is the answer.
397|Integer Replacement|Medium|08/17/2019|Inspired only by idea(developed code independently)|Bit Manipulation|||WithBitCountImplementation: TC: O((logn)^2), SC: O(1); CheckLast2BitNum: TC: O(logn), SC: O(1)|1. use bit right shift operation to half a even number (devide by 2), use bit and operation &1 to check a number is even or odd; 2. use &3 to check if a number's bit number ends with 11, if that's the case the we need to increase n, otherwise just shift to right by 1 step, it equals to decrese n by 1 and half it; 3. there is a special case when n = 3, in this case we need to descrese n; 4. beware of int32 boundaty, need to convert to long;
409|Longest Palindrome|Easy|08/17/2019|Yes|Hashtable / Greedy (to be implemented)|||Hashtable: TC: O(n), SC: O(n);|Hashtable: trivial, just count all characters, for even count char, add to result, for odd count char, only allow 1 to add it's full count, the result add count - 1 to result; Greedy: To be implmeneted
406|Queue Reconstruction by Height|Medium|08/20/2019|Yes|Sorting with customized Comparison/ Greedy (to be implementend)|||Sorting with customized Comparison: TC: O(nlogn), SC:O(n)|Sorting with customized comparision: 1. use Array.Sort(array, Comparison<T>), define a customized comparision using lambda expression, basically sorting firstly by height, and by taller people count; 2. filling the result array from the sortest people, place the current shorest people descreasing the taller person count whenever we meet a taller person or an null element until it reaches 0; 
412|Fizz Buzz|Easy|08/21/2019|Yes|Mod|||TC: O(n), SC: O(1)|trivial, use mod
414|Third Maximum Number|Easy|8/24/2019|Yes|Specific to problem|||TC: O(n), SC: O(1)|1. define 3 private int for first, second, third largest number, initial value is int.MinValue, a int to count the times of the third is changed to tell if third number is reached if it's greater or equals to 3; 2. create prviate function to update the first/second/third and to call it at each iteration of the num array, need to have special case for num[i] == int.MinValue;
413|Arithmetic Slices|Medium|8/25/2019|Yes|Math(Sum of Arithmetic Sequence)|||TC: O(n), SC: O(1)|1. if the max length of a arithmetic sequence(等差数列) is n, then the total number of its arithmetic slices is the sum of 1, 2, ..., (n - 3 + 1) = (1 + n - 3 + 1) * (n - 3 + 1) / 2 = (n - 1)(n - 2)/2
416|Partition Equal Subset Sum|Medium|8/25/2019|Inspired only by idea(developed code independently)|DP (0/1 knapsack problem)|||DP: TC:O(n*m); SC:(n*m), n: nums.Length, m: sum/2;|"define a boolean 2D array dp, that dp[i,j] means if the first i elements in the array nums can have a subset with a sum = sum(nums) / 2; transition function: dp[i,j] = dp[i - 1, j] || (j - nums[i] <  0 ? false : dp[i - 1, j - nums[i]])"
417|Pacific Atlantic Water Flow|Medium|8/25/2019|Yes|DFS (iterative) / BDS (to be implemented)|||DFS: TC:O(n*m), SC: O(n*m)|DFS: 1. define a 2d array to save the state of each element, 0: unvisited, 1: cannot flow to both ocean, 2: can flow to Pacific, 3: can flow to Atlantic, 4: can flow to both oceans; 2. use stack to do DFS iteratively; 3. make sure to have a 2d array to record visited element; 4. logic to update the state continously, e.g. when current state indicate it can flow to pacific, and current element's x or y index is the right and bottom boarder. then update state to 4. if current state is 4. then update the starting element to 4 too etc.
419|Battleships in a Board|Medium|8/26/2019|Yes|DFS (iterative) / Count top-left element|||DFS: TC: O(n*m), SC: O(n*m); Count top-left element: TC: O(n*m), SC: O(1)|DFS: trivial; Count top-left element: only count the first element in the battle ship which is the top-left element, in implementation, continue the iteration when both horizontal and vertial predecessor element is not 'X' and current element is 'X'
421|Maximum XOR of Two Numbers in an Array|Medium|8/28/2019|No|brute force / bitwise operation|||BruteForce: TC:O(n^2), SC: O(1); Bitwise: TC:O(n), SC: O(n)|"brute force: trivial; Bitwise: 1. starting form the MSB(most significant bit, 31 in this problem) and only consider the the left part of number length start from; 2. use a mask and & to get the left part from numbers, and add them into a hashSet; 3, define a greedy target number which will be the max | 1 << i, iterate the hashSet and try to see if there exists another number = target ^ curLeftNumber, because for XOR, the order can be any and the equation will always be valid,  if a = b ^ c then b = a ^ c, if found then break current iteration in the hashset, because we don't care how many pairs can give us the greedy target, in the next iteraton on the next bit number, the valid pair(s) will only come from pair(s) from current bit number's iteration "
423|Reconstruct Original Digits from English|Medium|8/29/2019|Yes|Specific to problem|||TC: O(n), SC: O(1)|1. define a int array length = 26 for counting the characters in the provided string, another int array length = 10 to save the number count from 0-9; 2. find a specifc order of number 0-9 to remove the chars of the number name in the char array such that every number to be removed has one unique character. e.g. z(zero), g(eight), u(four), w(two), x(six), o(one), t(three), f(five), s(sevem), i(nine); 3. subtract char count from the char array, and add count in the number array.
424|Longest Repeating Character Replacement|Medium|8/30/2019|Yes|two pointers (sliding window)|||TC: O(n), SC: O(1)|1. define a int array length = 26 for counting the characters of the sliding windows(left to right), define 2 indexes left and right; 2. define a private method to calculate the count of replacement needed for current window by counting the sum of all characters subtracted by the count of the most character; 3. sliding the window while right < s.Length; if replace count <= k, slide right index rightwards; else slide left index to rightwards;
427|Construct Quad Tree|Medium|9/1/2019|Yes|Recursion|||TC: O(n), SC: O(n)|1. recursion is trivial, just be noted that the way of getting child node index is e.g. for x axis, left: xlo, (xlo + xhi)/2, right: (xlo + xhi)/2 + 1
429|N-ary Tree Level Order Traversal|Easy|9/3/2019|Yes|BFS (iterative)|||TC: O(n), SC: O(n)|1. use a queue to BFS traversal the tree, the datatype of the queue element is keyvaluepair<int, Node>, where the int is the level and Node is the current node; 2. when the current level is not equal to the length of the result's last element, add a new element in the result;
430|Flatten a Multilevel Doubly Linked List|Medium|9/7/2019|Yes|DFS (iterative)|||DFS(Iterative): TC: O(n), SC: O(n)|iterative: 1. define a stack, a dummyhead; 2. keep popping up the stack, and push popped node's next to the stack, when a node poped from the stack has a child, push the child after pushing of the next; 3. before returning dummyHead.next, reset dummyHead.next.prev to null. iterative(optimized): define a stack, but this time it's only used when a node with child is met, push the cur.next  to the stack in order to no lose the track of this node when the iteration of the child's list is done. break the loop when stack is empty and cur.next is null;
434|Number of Segments in a String|Easy|9/11/2019|Yes|trivial|||TC: O(n), SC: O(1)|iterate the char in the string, increase the result when previous char is a space but current char is not.
433|Minimum Genetic Mutation|Medium|10/14/2019|Yes|BFS(Queue)|||TC: O(n^2), SC: O(n)|1. create 2 queues for gene string and mutation counts; 2. create a private method, acception 2 string to check if the first string is a one step mutation of the 2nd one; 3. before starting BFS queue iteration, check if the end gene exist in the bank, return -1 if it doesn't (once the iteration starts we will be sure the curGene is in the bank); 3. in the while body, first check if the start is a one step mutation of curGene, if yes, return the mutation count +1; 
437|Path Sum III|Easy|10/19/2019|Yes|DSF(Recursive)|||TC: O(n^2), SC: O(n)? Or O(n^2)|1. this problem is a very good problem to train the mind of solving problem recursively. There are 2 recursions, one embeded in another. Also need to learn how to summarize the result from the bottom to the top when the method returns an integer as the result. 
435|Non-overlapping Intervals|Medium|10/20/2019|No|ISMP(Greedy)|||TC:O(nlogn), SC: O(1)|1. define a private method that sort intervals by the finishing number; 2. sort the intervals array; 3 define a max count with initial value of 1, define a end var with inital value of the first element's finishing number, iterate from the 2nd element in the sorted intervals, advancing the max count when the finishing number of the previous element is less or equal than the current element's starting number. and update the end var to current element's finishing number; 4. answer will be intervals.Length - max;
438|Find All Anagrams in a String|Medium|11/08/2019|Yes|Hashtable(sliding window)|||TC: O(n), SC: O(m), n: s.Length, m: q.Length|1. basically it's a sliding window of fixed width, sliding from left to right; 2. the right element to be added to the window, when there is same char found in the dict, remove it, otherwise add it; 3. the left lement to be removed from the window, when this char can be found in the dict, remove it, otherwise add it back, it means it must be removed earlier if we cannot find it.
441|Arranging Coins|Easy|11/09/2019|Yes|Math|||TC: O(n^1/2)?, SC: O(1)|1. Use the knowledge of the sum of a arithmetic sequence is (1+k)k/2, if the n can form a perfect staircase without coins left, then n=(1+k)k/2, so if we calculate the square root of x=sqrt(2n), then we are sure x bigger than k, we can iterate from x and decreasing it by 1 till we found the first k where (1+k)k/2 < n. The k is the answer  
442|Find All Duplicates in an Array|Medium|11/10/2019|No|Specific to problem|||TC: O(n), SC: O(1)|1. one pass iteration, because 1<= nums[i] <= nums.Length, flip the nums[Math.Abs(nums[i])] to its negative counterpart, if it's already nagative, then it means nums[i] appears more than once
567|Permutation in String|Medium|11/14/2019|Yes|Sliding window|||TC: O(n), SC: O(m), n: s2.Length, m: s1.Length|1. define sliding window boundary index lo, hi, define the sliding window starts from lo+1 to hi, so initial value of lo is -1, hi is 0; 2. define a dictionary that records the char count of s1; 3. keep advancing the hi if there is char left in dict, deduct the count in the dict after advacing; 4; if s2[hi] is not found in the dict, advancing lo by 1 step and add s2[lo+1] back to dict.; 5 if lo > hi, reset hi = lo, this is for the case when meet a char that doesn't exist in s1; 
443|String Compression|Easy|11/17/2019|Yes|Two Pointers|||TC: O(n), SC: O(1)|1. define 2 pointers, one for the current iteration index, one for the index of the last elemet in the new string, define a varaiable store previous value, a counter to count duplicate characters; 2. iterate throught the array, continue of current element equals the previous, else then advance the new string index and append counter if it's greater than 1; 3. need a special logic for the last element, and this logic need to run after regular logic;
445|Add Two Numbers II|Medium|11/222019|Yes|Reverse LinkedList / Two stack|||Reverse list: TC: O(n), SC: O(n); Two stack: TC:O(n), SC: O(n);|Reverse list: leverage the sub function of reverse a linked list in place, reverse the 2 list first, then do the adding digit by digit, be noted of the advance, and case of any of the node being null; Two stack: define 2 stacks and push values of 2 list into them, then if any of the stack is not empty, keep poping value and add add them together, define a new list: result to store the new result, in each interation, the trick is to create a new listnode for the previous node, assign its value to sum/10, and assign prev.next = result, result = prev;
447|Number of Boomerangs|Easy|12/2/2019|Yes|Hashtable|||Hashtable: O(n^2), SC: O(n)|hashtable: the idea is to iterate from every points to other points, have a dictionary to count the distance, create a private function to calculate fractorial and permutation; after iteration of current from point is done, iterate the kvp in the dict, of the distance count is greater than 1, get the permutation and add it to the result; clear the dictionary before starting iteration for next from point;
448|Find All Numbers Disappeared in an Array|Easy|12/23/2019|Yes|memoization / in place swap|||memoization: TC: O(n), SC: O(n); In place swap: TC: O(n), SC: O(1);|memoization: trivial, use an int array that act as a hashtable to record the count of visited number, and do a 2nd pass to add num that with count = 0; In Place swap: iteration numbers in num and keep swapping the nums[i] with nums[nums[i] - 1] if: nums[i] !=  i + 1;
449|Serialize and Deserialize BST|Medium|12/24/2019|Yes|BFS(Queue)|||BFS(Queue): serialize: TC: O(n), SC: O(n); deserialize: TC: O(n), SC: O(n);|serialize: use 'n' for null nodes, serialize level by level top down using BFS; deserialize: use a queue to queue created nodes, split the string by delimiter and iterate through it; if current value is 'n' then skip, if no the create the node, queue it to the defined queue;
450|Delete Node in a BST|Medium|12/25/2019|No|DFS(recursive)|||DFS(recursive): TC: O(n), SC:O(n)|recursively check current node and it's child, if root.val != key, recursively pass root's left and right child to the same method and assign the returned node to left and right child, 4 cases: case 1: both left and right nodes are null;case 2: left node is not null, right is null;case 3: right node is not null, left is null;case 4: both left and right nodes are not null, find the minimum value in the right tree and change the value of root to it, delete the min node from the right sub-tree by calling the same method;
451|Sort Characters By Frequency|Medium|12/28/2019|Yes|Hashtable / bucket sort (TBI) / heap(priority queue)(TBI)|||Hashtable: TC: O(n), SC: O(n)|hashtable: trivial, create a dict, iterate the string and count the occurance of each char, define a number to keep the maxCount, and iterate the dictionary kvp to append characters count == maxCount, and decrease the maxCount, re-do the iteration again till maxCount == 0
452|Minimum Number of Arrows to Burst Balloons|Medium|02/08/2019|No|Greedy|||Greedy: TC: O(nlogn), SC: O(1)|Greedy: 1. sort balloons array by their ending index; 2. define return answer with intial value 1, and a current potision where the arrow should be shot, initial value is the first elements's ending index; 3. iterate the sorted array, when current balloon's starting index is greater than current arrow position, advance the count, because otherwise shot the arrow will also burst the current balloon;Here are the questions that can be solved with the same technique * 56 Merge Intervals <- very similar/435 Non-overlapping Intervals <- very similar/252 Meeting Rooms/253 Meeting Rooms II. Practice them in a row for better understanding
453|Minimum Moves to Equal Array Elements|Medium|02/09/2019|No|Math|||Math: TC: O(n), SC: O(1)|Math: 1. define n as the length of nums, x is the minimum moves, sum is the sum of the nums, min is the minimum element;2. for min, it should be added by 1 in every x moves, so n = min + x; 3.after x moves: sum + x(n - 1) = n(min + x) ==> x = sum - min*x
454|4Sum II|Medium|02/10/2019|No|BruteForce/Hashtable|||BruteForce: TC: O(n^4), SC: O(1); Hashtable: TC: O(n^2), SC: O(n^2)|Hashtable: 1. split the 4 arrays evenly into 2 groups, 2 arrays in each group, iterate the first group quadratic (n^2), define a hashtable stores count of all possible sum of 2 elements each from one array; 2. define an int as result, iterate the 2nd group quadraticly, if exists -1*(C[i]+D[j]) in the hashtable,  add the value of this key to result; 3: return result;
455|Assign Cookies|Easy|02/10/2019|Yes|Greedy|||Greedy: TC:O(nlogn+mlogm); SC: O(1)|Greedy: 1. sort both arrays; 2. define a index for child array, iterate cookies array, when current child will be content with current cookie, advance child index and advance result by 1; 3. need to make sure child index doesn't exceed child array's boundary.
456|132 Pattern|Medium|2/10/2019|No|Brute Force / Calculate intervals / Stack|||bruteforce: TC: O(n^2), SC: O(1); Calculate intervals: TC: O(n^2), SC: O(n), Stack: TC: O(n), SC: O(n)|Brute Force (official sol2): 1. iterate nums and keep update the min num so far, sub iterate to the right from current index i to find a number  num[j] that min < num[j] < num[i]; Calculate intervals(official sol3): 1. iterate nums and keep recording array of min numbers at each index, at every index i, search the backward the intervals  (min[j], num[j]) (j < i) to find a case that num[j] > num[i] > min[j]; Stack (official sol4): build min array as other approach, then interate from end of the nums backward, when num[i] > min[i], keep popping item from stack.Peek() < min[i], then check if stack.Peek() < num[i], then return true;
457|Circular Array Loop|Medium|2/12/2019|Inspired only by idea(developed code independently)|Two Pointers|||Two Pointers: O(n^2) ?, SC: O(1)|Two Pointers: 1. define a slow a fast point, slow pointer make 1 move at a time, faster make 2 moves at a time, when two pointers meet again, means there is a cycle; 2. iterate the nums array, each element as the starting point candidate, skip candidates with value of 0; 3. define a int with possible value [-1, 1] to indicate the directions, if direction changes during the move, or cycle length is 1, fail this candidate by update it's value to 0 as element with 0 will not be a valid candidate anymore.
458|Poor Pigs|Hard|2/13/2019|No|Math|||Math: TC: O(1), SC:O(1)|Math: check the discussion, this problem is essentially get the Ceiling of Log(buckets, maxRounds + 1)
459|Repeated Substring Pattern|Easy|2/13/2019|Yes|Mod|||Mod: TC: O(n^2), SC: O(1)|Mod: 1. iterate the possible length of the substring, and sub-iterate the string, check s[i%length] == s[i] 
461|Hamming Distance|Easy|2/14/2019|Yes|Mod/Bitwist Manipulation|||Mod: TC: O(logn), SC: O(1); Bitwise Maniputation: TC:O(1), SC: O(1)|Mod: trivial. Mod by 2; Bitwise Manipulation: use ^ and then doing a while count the time of n &= n-1 till n reaches 0;
462|Minimum Moves to Equal Array Elements II|Medium|2/15/2019|No|Sort/Quickselect(recursion)/Quickselect(iteration)|||Sort: TC: O(nlogn), SC: O(1); Quickselect(recursion): TC: O(n), SC: O(logn)?; Quickselect(iteration) TC:O(n), SC: O(1)|general idea is to find the value of the median in the sorted array, regardless whether the length of nums is even or odd, for even, moves at length /2 or length/2 - 1 will always be the same because median is between then. Use quickselect to find the median will have better time complexity.
463|Island Perimeter|Easy|2/16/2019|Yes|trivial Iteration/BFS(Queue)|||iteration: TC: O(n*m), SC: O(1); BFS(queue): TC: O(n*m), SC: (n*m)|define a array of 4 element for the indexes shifting of 4 neighbours, no matter solve it by iteration or BFS, just advance the perimeter count by 1 under only 2 cases: neighbour doesn't exist, exceede boarder; neighbour's value is 0; 
464|Can I Win|Medium|2/16/2019|No|DP(Top-down with Momoization)|||DP: TC: O(2^n)?; SC: O(2^n)?|DP: backtracking approach, but define a memoization dictionary to optimize time complxity, this memo dictionary use string in 0 and 1 that denotes visited(used) integer, to a bool value indicating if under this case can I win or not. It's very important to revert value of visited integers with iterations; define a helper method to be called recursively, with bool return type, the tricky part is to validate this return value's compliment value (!helper(...)) in the parent call, it means if my component can win, then I will for sure to lose. 
467|Unique Substrings in Wraparound String|Medium|2/17/2019|Inspired only by idea(developed code independently)|BruteForce(TLE)/DP|||BruteForce: TC:O(n^2), SC:O(n); DP: TC: O(n), SC: O(1)|DP: 1. create an int array length = 26 to memo the max length of substring ends with one of the 26 alphabet; 2. iterate the char in the string and keep comparing and updating the max length in this int array; 3. for each max length x of a specific alphabet, the count of all unique substring that ends with this alphabet equals the max lenght. e.g. for letter 'd', max length = 4, means max substring is abcd, and all unique substring ends with d are abcd, bcd, cd, d, count = 4; 
468|Validate IP Address|Medium|2/17/2019|Yes|String|||String: TC:O(1), SC: O(1)|trivial, just need to make sure some coner cases like -1 in ipv4 
1352|Product of the Last K Numbers|Medium|2/18/2019|Yes|Specific to Problem|||TC: O(1) (amortized); SC: O(n)|1. based on the fact that if there is a 0 in last k numbers, the product will be 0; 2. define an integer to keep tracking the index of the last zero, define a list to keep the product from last zero to current element; 3. if k exceeds last zero, return 0; else, return _products[_products.Length - 1] / _products[_products.Length - k - 1] 
1351|Count Negative Numbers in a Sorted Matrix|Easy|2/18/2019|Yes|Binary Search(1D on rows)|||Binary Search(1D on rows): TC: O(mlogn), m:grid.Length, n:grid[0].Length; SC: O(1)|Binary Search(1D on rows): 1. iterate on rows and find each rows' first negative number index n by binary search; 2. define a last calculated column index iColumn starting by grid[0].Length+1; 3. accumulate negative count by counting the area the between n and iColumn; 
1353|Maximum Number of Events That Can Be Attended|Medium|2/19/2019|No|Greedy|||Greedy: TC: O(nlogn), SC: O(n)|Greedy: 1. sort the intervals's ending time in desending order, if tie sort the starting time by ascending order; 2. iterate the sorted array and try use the right most day first; 3. define a hashset to record days that already attended;
470|Implement Rand10() Using Rand7()|Medium|2/19/2019|Yes|Random(2x5)/Random(49-40-10)|||Random(2x5): TC: O(1), SCL O(1); Random(49-40-10): TC: O(1), SC: O(1)|Random(2x5): 1. create a method accepting an int x parameter to implement rand(x) based on rand7, to do it just keep calling rand7 when the random result is greater than x; 2. final rand10 will be rand(5) if rand(2) = 1, 5+rand(5) if rand(2)=2; Random(49-40-10): 1. rand(49) = 7*(rand(7)-1)+rand(7); use keep calling rand(49) until its result is less than or equal to 40, because the probably of getting every number in 1-49 is equal, if we deliberly omit 41-49, then the probably of us getting every number in 1-40 is still equal, make it legit rand(40); 2. now we have rand(40), to get rand(10), since 10 a divisor (约数) of 40, just use mod: rand(10) = rand(40)/10 + 1; think about we combine 1,11,21,31 to 1 of ra d(10)
472|Concatenated Words|Hard|2/20/2019|Yes|DP/Trie|||DP: TC: O(m*n2) ; SC: O(m); Trie: TC: O(m*n2) ; SC: O(m); n: word length, m. words count|DP: based on word break(137); Trie: implement a Trie class, add all the words into the trie, and iteration every word in words, create a helper method be called recursively about every substring of current word, until the remaining substring can be found in the trie
140|Word break II|Hard|2/20/2019|inspired only by idea(developed code independently)|DP(TLE)/DFS(Recursion) with Memoization|||DP: TC: O(n^2), SC: O(n); DFS:?|DP: same as work break 1; DFS: the trick is for a substring of s, the sub-problem of getting all the possible breaked words by a give wordDict can be reused, so we can memorize it to avoid process same substring twice;
473|Matchsticks to Square|Medium|2/21/2019|inspired only by idea(developed code independently)|DFS(Recursion)|||DFS(Recursion): exponential|DFS(Recursion): native DFS is trivial and will have TLE problem, 2 way to optmize: 1. calculate the sum /4 as the target and to make sure next recursion's length won't be greater than that, it will elimitate a lot unneeded recursions; 2. sort the array in decending order so that longer match stick will be used first, it will make the target check fail earlier, and try to use longer match stick in higher priority make it more optmized;
698|Partition to K Equal Sum Subsets|Medium|2/21/2019|Yes|DFS(Recursion)|||same as 473